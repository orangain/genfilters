#!/usr/bin/env -S deno run --allow-read --allow-write
import { FilterConfig, parseConfigFile } from "./config.ts";
import {
  basename,
  dirname,
  ensureDirSync,
  existsSync,
  join,
  relative,
} from "./deps.ts";
import { globDirectories } from "./glob.ts";

// Default config file name
const DEFAULT_CONFIG_FILE = "genfilters.yaml";

/**
 * Main function
 */
async function main() {
  try {
    // Get config file path from command line args or use default
    const configPath = Deno.args.length > 0
      ? Deno.args[0]
      : DEFAULT_CONFIG_FILE;

    console.log(`Using config file: ${configPath}`);

    // Read and parse the YAML config file
    const yamlContent = await Deno.readTextFile(configPath);
    const configs = parseConfigFile(yamlContent);

    console.log(`Found ${configs.length} configurations to process`);

    // Process each configuration
    for (const config of configs) {
      await processConfig(config);
    }

    console.log("All configurations processed successfully");
  } catch (error) {
    const message = error instanceof Error
      ? error.message
      : "An error occurred";
    console.error(`Error: ${message}`);
    Deno.exit(1);
  }
}

/**
 * Processes a single configuration entry
 */
async function processConfig(config: FilterConfig): Promise<void> {
  console.log(`Processing config for output: ${config.output}`);

  // Create an array to store the processed template results
  const results: string[] = [];

  // Find all directories matching the pattern
  const directories = await globDirectories(config.directory);
  for (
    const directory of directories
  ) {
    const result = processDirectory(directory, config);
    if (result) {
      results.push(result);
    }
  }

  // If we have results, write them to the output file
  if (results.length > 0) {
    const outputContent =
      "# This file is auto-generated by genfilters. Do not edit manually.\n" +
      results.join("");

    // Ensure the output directory exists
    ensureDirSync(dirname(config.output));

    // Write the output file
    await Deno.writeTextFile(config.output, outputContent);

    console.log(`Generated ${config.output} with ${results.length} entries`);
  } else {
    console.log(
      `No matching directories found for pattern: ${config.directory}`,
    );
  }
}

/**
 * Process a single directory for a given configuration
 */
function processDirectory(
  dirPath: string,
  config: FilterConfig,
): string | null {
  const dirRelativePath = relative(Deno.cwd(), dirPath);

  // Check if match-if-exists file exists if specified
  if (config["match-if-exists"]) {
    const filePath = join(dirPath, config["match-if-exists"]);
    if (!existsSync(filePath)) {
      return null;
    }
  }

  // Get the directory name (basename)
  const dirName = basename(dirPath);

  // Apply template
  return applyTemplate(config.template, dirRelativePath, dirName);
}

/**
 * Apply template substitution for a directory
 */
export function applyTemplate(
  template: string,
  dirPath: string,
  dirName: string,
): string {
  if (!template.endsWith("\n")) {
    template += "\n"; // Ensure the template ends with a newline
  }
  return template
    .replaceAll("{dir}", dirPath.replaceAll("\\", "/")) // Normalize path separators for cross-platform reproducibility
    .replaceAll("{dirname}", dirName);
}

// Run the main function
if (import.meta.main) {
  main();
}
